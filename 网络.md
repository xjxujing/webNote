[TOC]



www万维网： 是一个由许多互相链接的超文本组成的系统，通过互联网访问

URL: 统一资源定位符，通过url可以得到资源的位置

## URL到Web

从输入URL到web页面呈现：

~~~html
1. 输入地址
   域名（IP地址别名）     cmd中   ping   域名	得到IP地址

2. 解析域名需要DNS服务器		hosts本地文件可以暂时存储

3. TCP/IP连接  (三次握手)
   客户端请求连接 SYN数据包
   服务器确认信息 ACK/SYN数据包
   客户端握手结束 ACK数据包
   （TCP有链接	UDP无链接 不够安全 会丢包 可能适用音频或语音）

4. 客户端向服务器发送请求     √

5. 接收处理请求

6. 向浏览器返回响应    √

7. TCP/IP关闭（四次挥手）
   客户端请求断开 FIN数据包
   服务器已接收 ACK数据包
   服务器同意断开 FIN数据包
   客户端已接收断开 ACK数据包

8. 解析HTML、渲染页面
~~~



## 集成环境安装及使用

一、服务器的作用	配置服务器

`php` 后端程序语言

`apach `运行网站的服务

`mysql` 数据库

二、为什么要使用`wamp/mamp`

`Wamp`就是`Windows Apache Mysql`
`PHP`集成安装环境，即在`window`下的`apache`、`php`和`mysql`的服务器软件。帮助我们一次安装并设置好

> 直接官网下载http://www.wampserver.com/en/
> 缺系统文件https://www.microsoft.com/zh-CN/download/details.aspx?id=48145下载



## 手动封装Ajax兼容性写法

异步获取数据，并且是局部获取

~~~javascript
ajax（Asynchronous JavaScript and XML 异步的javaScript和xml)
~~~

可实现异步、局部的获取数据

一、`XML and json`

(1)` json`

      ~~~java
JSON.stringify({a: 12,b:5})   转成字符串
JSON.parse() // 解序列化 转成json 注意要是标准写法 双引号

key和value必须要有双引号，不过js中可以简写
双引号在有的语言中表示字符
      ~~~

(2)XML 是可拓展的标签语言，可自定义标签，基本不用了

~~~html
自定义标签
<name>aimee<name>
<age>18<age>
~~~



二、Ajax获取数据

GET请求获取新闻列表

POST请求传递username 和 age



三、封装Ajax

模拟定外卖过程：

| 定外卖                       | 请求数据                                             |
| ---------------------------- | ---------------------------------------------------- |
| （1）手机/电脑               | （1） web浏览器                                      |
| （2）打开app 饿了么/美团外卖 | （2） ajax对象                                       |
| （3）商家 商品 地址          | （3） 初始化 HTTP 请求参数(请求方式, 地址, 同步异步) |
| （4）下单 （不要麻辣不要烫） | （4） 发送请求                                       |
| （5）监控物流信息            | （5） 监控数据                                       |
| （6）下楼 验货 吃            | （6） 检查数据 使用                                  |



###   监控数据

  `readyState`五种状态     状态发生变化的时候会触发`onreadystatechange`事件

~~~html
0 － （未初始化）还没有调用send()方法 
1 － （载入）已调用send()方法，正在发送请求 
2 － （载入完成）send()方法执行完成，已经接收到全部响应内容 
3 － （交互）正在解析响应内容 
4 － （完成）响应内容解析完成，可以在客户端调用了
~~~

HTTP状态码 status

~~~HTML
1xx:信息类,表示web浏览器请求,正在进一步的处理中
2xx:成功,表示用户请求被正确接收正在进一步的处理中 200 OK
3xx:表示请求没有成功,客户端必须采取进一步的动作
4xx:客户端错误,表示客户端提交的请求有错误 例如:404 NOT Found{errcode:2} 
意味着请求中所引用的文 档不存在
5xx:服务器错误 表示服务器不能完成对请求的处理,如500
~~~



### 原生ajax封装

~~~javascript
// （1） web浏览器
// （2） ajax对象       
// （3） 初始化 HTTP 请求参数(请求方式, 地址, 同步异步)
// （4） 发送请求
// （5） 监控数据        
// （6） 检查数据 使用

function ajax(method, url, callback, data, flag) {
    // 创建ajax对象,IE6及以下没有XMLHttpRequest方法,注意兼容
    var xml;
    if (window.XMLHttpRequest) {
        xml = new XMLHttpRequest();
    } else {
        xml = new ActiveXObject("Microsoft.XMLHttp");
    }

    // 注意HTTP请求方式用大写(请求方式, 地址, 同步false异步true)
    // xml.open("GET", "./getNews.php?" + data, true); // GET请求 获取数据
    // xml.open("POST", "./post.php", true);  // POST请求 传数据

    // 发送请求
    // xml.send();
    // xml.setRequestHeader("Content-type", "application/x-www-form-urlencoded ");  // 传递请求头
    // xml.send(data); // 在这里传数据

    method = method.toUpperCase();  // 兼容小写写法的协议，注意应该要大写
    if (method == "GET") {  // 注意GET有缓存 向同一个地址(url)多次发送请求,会有缓存,不从服务器拿,导致不能及时拿到新数据(比如验证码获取),可以加时间戳或随机数
        var date = new Date();
        timer = date.getTime();
        xml.withCredentials = true; // 是否允许cors跨域的时候携带凭证
        xml.open(method, url + "?" + data + "&timer=" + timer, flag); // GET请求 获取数据
        xml.send();
    } else if (method == "POST") {
        xml.open(method, url, flag);  // POST请求 传数据
        xml.setRequestHeader("Content-type", "application/x-www-form-urlencoded ");  // 传递请求头
        xml.send(data); // 在这里传数据
    }

    // 监控数据 0 1 2 3 4
    xml.onreadystatechange = function () {
        // console.log(xml.readyState);
        if (xml.readyState == 4) { // 响应内容解析完成
            // 检查数据 
            if (xml.status == 200) { // 请求成功
                // cbs(xml.responseText);
                // cbs2(xml.responseText);
                callback(xml.responseText)
            }
        }
    }
}
~~~



对比`$.ajax()` 这里用的是小米商城整站接口封装后的部分代码

~~~javascript
api: function( method, path, data, context ) {
		const HOST = 'http://vip.chanke.xyz/mi';
		return $.ajax({
			method: method,
			url: HOST + path,
			// 通过Token字段认证, 存储在localStorage,注意不是cookie,
			headers: {
				Token: this.getToken()
			},
			// 禁用 cookie 模式
			// xhrFields: {
			// 	withCredentials: true  // 是否允许cors跨域的时候携带凭证
			// },
			data: data,
			context: context || this,
		}).then(function( data, textStatus, jqXHR ) {
			// 成功时只取有效内容
			if (!data.errorCode && data.data) {
				return data.data;
			}
		}, function( jqXHR, textStatus, errorThrown ) {
			// 通用失败处理,除了请求失败,还有可能请求成功,但是返回的是失败信息
			let errorMsg;
			if (jqXHR.responseJSON && jqXHR.responseJSON.errorMessage) {
				errorMsg = jqXHR.responseJSON.errorMessage;
			} else {
				errorMsg = errorThrown || textStatus;
			}
			// this 即 context，可控制失败处理方式
			if (this.silent) {
				console.warn(jqXHR);
				console.warn(errorMsg);
			} else {
				window.alert(errorMsg);
			}
			// 确保接下去依然进入 fail 分支
			return $.Deferred().reject();	// 同 return Promise.reject();
		});
	}
使用:
api(传入参数).done(function() { // 成功执行啥啥啥
    ...
}).fail(function () { // 失败执行啥啥啥
    ...
})
~~~





## HTTP协议是什么

超文本传输协议（HTTP，HyperText Transfer
Protocol)是用于从web服务器传输超文本到web浏览器的传送协议。所有的WWW文件都必须遵守这个标准



互联网中传递不同的东西需要不同的协议

- 网页传输 HTTP协议
- 邮件传入 mail协议
- 文件传输  FTP协议
- 本地文件   file协议

### 报文

报文首部：需要处理的内容和某些属性。在客户端和服务器处理时起至关重要作用的信息几乎都在这边

报文主体：应该被发送的数据（不需要发送数据时可没有报文主体）所需要的用户和资源的信息都在这里

| 请求报文                                                     | **响应报文**                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 报文首部：<br />请求行:请求方法 URL 版本及协议<br />请求首部:包含表示请求和响应的各种条件和属性的各种首部 | 报文首部：<br />响应行:状态码 原因短语  协议及版本<br />响应首部:包含表示请求和响应的各种条件和属性的各种首部 |
| 报文主体                                                     | 报文主体                                                     |
|                                                              |                                                              |



### 请求方法

GET: 获取资源

POST: 传输主体内容

GET 和 POST请求比较相似，说一下他们的区别？

​    其实GET请求和POST请求本质上没有什么区别，因为他们底层都是TCP链接。

​    （1）那为什么GET请求参数要放到URL中，而POST要放到body里呢。只不过是在请求的时候，为了交互数据的时候能更清晰一些，HTTP协议规定GET要放到url中

​    （2）GET请求在URL中传送的参数是有长度限制的，而POST没有

​        一次传输数据量太大对浏览器和服务器都是很大负担。而且如果服务器不做处理的话，恶意攻击传入大量数据容易导致服务器崩溃。

​    （3）至于说POST请求比GET请求安全，那仅仅是因为get放到了url中而已。

PUT: 传输文件	不带验证机制

DELETE: 删除文件	不带验证机制

OPTIONS: 查询支持的方法

HEAD: 获得报文首部	不要资源，其他与GET一样



### URL

协议：http:/https: 不区分大小写

登录信息：用户名和密码从服务器获取资源师必要的登录信息。此项可选 USER:PASS

域名：

​        chanke.com一级域名

​        www.chanke.com二级域名（也称子域名）

​        aa.bb.chanke.com 三级域名

​		*三级是二级的子域名	二级是一级的子域名*

​        后面的com属于顶级域名，还有和很多顶级域名

​        com（商业机构） net（互联网服务的机构）  org(非盈利组织)   cn（中国） com.cn(中国商业机构)

端口：服务器连接的网络端口号（可省略。:80 【http协议】:443【https协议】）



### 协议及版本

HTML/1.0 非持久连接。但是通过非标准手段也可以实现持久连接

HTML/1.1 默认持久连接   没有挥手 不用频繁创建和断开TCP链接



### 状态码

HTTP状态码 status

​    1xx:信息类,表示web浏览器请求,正在进一步的处理中

​    2xx:成功,表示用户请求被正确接收正在进一步的处理中 200 OK

​    3xx:表示请求没有成功,客户端必须采取进一步的动作

​    4xx:客户端错误,表示客户端提交的请求有错误 例如:404 NOT Found{errcode:2} 

​            意味着请求中所引用的文档不存在

​    5xx:服务器错误 表示服务器不能完成对请求的处理,如500



### 常见状态码

2XX 成功 响应结果表明请求被正常处理了。

​    200 OK 表示从客户端发来的请求在服务器端被正常处理了



3XX 重定向  响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

​    301 Moved Permanentl永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URL。

​    302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问

​    304  重新定位服务器取缓存资源



4XX 客户端错误 响应结果表明客户端是发生错误的原因所在

   403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。

​    404 Not Foud 该状态码表明服务器上无法找到请求的资源。



5XX 服务器错误 的响应结果表明服务器本身发生错误。

​    500 Internal Server Error 该状态码表明服务器端在执行请求时发生了错误。

​    503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求



### 报文首部

四种首部字段（按功能分）：

**通用首部字段**：请求报文和响应报文两方都会使用的 

**请求首部字段**：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、       响应内容相关优先级等信息。

**响应首部字段**：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息

**实体首部字段**：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。



## 巧妙的JSONP跨域

### 同源策略

同源策略是浏览器的一种安全策略。

**协议** **域名** **端口**均相同的源才属于同源

- 同源策略阻止从一个源加载的文档或脚本获取或设置另一个源加载的文档的属性

- 当浏览器的tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，

- 如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。

以下哪些与http://vip.chanke.xyz/chanke/index.html同源？

http://www.chanke.xyz/chanke/index.html 域名不同

http://vip.chanke.xyz:81/chanke/index.html 端口不同

https://vip.chanke.xyz/chanke/index.html 协议不同

http://vip.chanke.xyz/aimee/index.html 同源



这些能访问到吗？

<img
src="https://www.baidu.com/img/bd_logo1.png?qua=high&where=super"
alt="">

<iframe
src="https://www.baidu.com/"
frameborder="0"></iframe>

<script
src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

<script>dd({})</script>
*利用script标签src不受同源策略限制的特点，src连接接口获取数据*

iframe两边的框是可以去掉的



重点！考点：

以什么形式有效的返回数据？需要前端怎么配合

jsonp接口：https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=so&cb=cbs

参数： cb=回调函数名称 	wd=关键字

dd({}) 







## history历史记录管理

window对象通过history对象提供对浏览器历史记录的访问能力，允许用户在历史记录中自由的前进和后退，而在HTML5中，还可以操纵历史纪律中的数据。

ajax获取数据是局部获取，不会刷新整个页面，意味着不会有新的历史记录添加

`history.pushState(ststateObjateObj,'page2', 'bar.html')` 添加一条历史记录

​		不会刷新页面，第二个参数目前可以不写

`history.replaceState(ststateObjateObj,'page3', 'bar.html')` 替换当前历史记录

`window.onpopstate =function(e) {console.log(e.state);} `历史记录发生发生变化时触发。上面两种不会触发该事件，只有前进和后退历史才会触发   通过e.state获取数据

解决问题：无刷新历史记录切换



## Cookie使用机制

HTTP是无状态的请求/响应连接，导致连接断开后，再次连接服务器无法识别用户

我们就需要用一些技术来帮助服务器去识别用户:

1、跟踪客户端IP地址。动态IP

2、借助http首部放置用户身份信息。referer、e-mail

3、胖URL 在URL中嵌入识别信息 。丑陋，无法共享URL，非持久等

4、cookie 在客户端存储用户标识信息。识别用户，持久化最好的方式。



### cookie原理

1、首次访问Web站点时，web服务器对用户一无所知。web服务器希望这个用户再次回来还能认识它。所以想给这个用户一个标识。标签。set-cookie: user_id=aimee123的响应首部

2、服务器返回响应的时候会带有响应首部set-cookie字段。浏览器会自动的把响应的cookie存储在浏览器数据库中（就是文本文件，存储不了一些cookie字段）

3、当用户再次访问同一站点时，浏览器会把存储的cookie一起带上发送出去，这样服务器在拿到请求的同时也拿到这这个cookie字段，知道你曾将来过，找与这个令牌相对应的数据返回



### cookie分类

1、会话cookie  用户退出浏览器时 会话cookie就被删除了

2、持久cookie  存储在硬盘上，浏览器退出计算机重启时仍然存在。可以维护用户周期性访问的站点。



### cookie属性

1、cookie域

2、cookie路径

3、cookie存储时间



`document.cookie`获取`cookie`或设置`cookie`

~~~javascript
设置时间点
document.cookie = "id=1234; max-age=1000";


设置时间段
var oDate = new Date();
oDate.setDate(oDate.getDate() + 1);
document.cookie = "id=1234; expires=" + oDate;

时间设置在前面就可以删除cookie
~~~



cookie存储大小：

|      |      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |







## webStorage本地存储

本地存储可以使用cookie，但是`cookie`本地存储不便：大小限制 （4k） 、随http传输

`storage`本地存储容量大（5M）进供本地存储使用

`sessionStorage` 临时存储 浏览器关闭存储结束

`localStorage` 永久存储 除非用户手动删除



### 操作

`storege`存取的是字符串类型

1、基本添加和读取

~~~javascript
添加：
localStorage.user = 'aimee';
localStorage.objj = JSON.stringify(obj);

读取：
localStorage.user;
JSON.parse(localStorage.objj );
~~~



2、API操作添加和读取

~~~javascript
localStorage.setItem('id',12345)   // 增 改

localStorage.getItem('id')   // 查

localStorage.removeItem('id')	// 删

localStorege.clear(); 
~~~



## CORS跨域源共享

cross-origin resource sharing (CORS) 跨域资源共享，是一种使用额外**HTTP首部**实现跨域获取资源权限的机制。 

`XMLHttprequest`获取非同源资源会被浏览器拦截。

`eg：localhost`下的资源发送XMLHttprequest请求同源、非同源资源



### CORS分类

一、简单请求

1、使用下列方法之一：

​    `GET POST HEAD`  

2、content-Type值为下列之一：

   `text/plain `

   ` multipart/form-data `

​    `application/x-www-form-urlencoded `

等……

除了正常发起请求外，若想实现`cors`跨域，还需要服务器配置正确的响应首部。否则无法获取

`php`中添加`access-contral-allow-origin: *  (localhost) `            访问控制允许源

*可以再MDN上查阅什么条件符合简单请求*



二、预检请求

“需预检的请求”要求必须首先使用 `OPTIONS` 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。

"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。



当请求满足下述任一条件时，即应首先发送预检请求：

1、使用非GET POST HEAD方法

2、content-Type值不为下列之一：

​        text/plain 

​        multipart/form-data 

​        application/x-www-form-urlencoded 

3、人为设置了 CORS 安全的首部字段集合之外的首部字段，如人为的写一个。

 CORS 安全的首部字段集合：https://fetch.spec.whatwg.org/#cors-safelisted-request-header



发起POST请求，人为设置了X-user：aimee字段，则需要预检请求。

要求服务器设置正确字段。

~~~javascript
Access-Control-Allow-Origin: *

Access-Control-Allow-Methods: POST, GET, OPTIONS;// 实际请求所允许使用的 HTTP 方法

Access-Control-Allow-Headers: X-PINGOTHER, Content-Type;//请求中允许携带的首部字段

Access-Control-Max-Age: 86400;//请求的结果能够被缓存
~~~





## postMessage 通信

不同html下访问变量

~~~html
index.html
<html>
    <body>
        <button class="btn">btn</button>
         <iframe src="./demo/html" style="border: 1px solid black" frameborder"0" name="demo"></iframe>
    </body>
    <script>
    var oBtn = document.getElementsByClassName("btn")[0];
        oBtn.onclick = function () {
            console.log(a); // 访问不到
            console.log(window.frames["demo"].a); // 可以访问到 在谷歌试了不行，火狐可以，可能是没放在服务器下面
            
        }
    </script>
</html>


demo.html
<html>
    <script>
    var a = 2;
    </script>
</html>


浏览器限制了javascript的权限，不能进行各种的读写。
~~~



`postMessage`

该`window.postMessage()`方法安全地启用Window对象之间的跨源通信。提供一种受控制的机制来安全地规避这种限制。

使用`targetWindow.postMessage()`
在其上发送一个`MessageEvent`。然后，接收窗口可根据需要自由处理此事件。传递给`window.postMessage()`的参数（即`“message”`）通过事件对象暴露给接收窗口。

`otherWindow.postMessage(message, targetOrigin);`发送数据

`message`事件会响应`postMessage`发送的的数据



## WebSocket双向通信

`WebSocket `对象提供了一组 API，用于创建和管理`WebSocket`连接, 以及通过连接发送和接收数据.

`Websocket `其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已.借用了HTTP的协议来完成握手



### 建立连接

当Web应用程序调用`new WebSocket(url)`接口时，Browser就开始了与地址为`url`的`WebServer`建立握手连接的过程。

1. `Browser`与`WebSocket`服务器通过`TCP`握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。

2. 在`TCP`建立连接成功后，`Browser`通过`http`协议传送`WebSocket`支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。

3. `WebSocket`服务器收到`Browser`发送来的请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。

4. `Browser`收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发`onopen`消息，此时`Web`开发者就可以在此时通过`send`接口向服务器发送数据。否则，握手连接失败，`Web`应用程序会收到`onerror`消息，并且能知道连接失败的原因。



### 使用

1、创建`webSocket`

​       `var Socket = new WebSocket(‘ws://echo.websocket.org’);`

2、`Web Socket` 方法

​       `Socket.send()`方法使用连接传输数据。

​      `Socket.close()`用于终止任何现有连接

3、事件

​       `WebSocket.onclose`用于指定连接关闭后的回调函数

​       `WebSocket.onerror`用于指定连接失败后的回调函数

​       `WebSocket.onmessage`用于指定当从服务器接受到信息时的回调函数

​       `WebSocket.onopen`用于指定连接成功后的回调函数



`WebSocket`的优点

​     1、客户端与服务器都可以主动传送数据给对方;

​     2、不用频率创建TCP请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源;



## RESTful

